<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Es class by kaitlin</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/main.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>

      <header>
        <h1>Fun with Elasticsearch!</h1>
        <p>The basics of installing and querying Elasticsearch</p>
      </header>

      <div id="banner">
        <span id="logo"></span>

        <a href="https://github.com/kaitlin/es_class" class="button fork"><strong>View On GitHub</strong></a>
        <div class="downloads">
          <span>Downloads:</span>
          <ul>
            <li><a href="https://github.com/kaitlin/es_class/zipball/master" class="button">ZIP</a></li>
            <li><a href="https://github.com/kaitlin/es_class/tarball/master" class="button">TAR</a></li>
          </ul>
        </div>
      </div><!-- end banner -->

    <div class="wrapper">
      <nav>
        <ul></ul>
      </nav>
      <section>
        <h1>
<a id="welcome-to-elasticsearch" class="anchor" href="#welcome-to-elasticsearch" aria-hidden="true"><span class="octicon octicon-link"></span></a>Welcome to Elasticsearch!</h1>

<p>Elasticsearch is a full text search engine. It is a scalable, RESTful interface built on top of the Lucene search engine. </p>
<p>Elasticsearch is similar to other search technology like Solr, in that they both run atop Lucene. However, Elasticsearch is optimized for scaling up and out, with built in management that allows one Elasticsearch index to be replicated across many machines. Compared to Lucene, Elasticsearch also has a RESTful API, which means any program that can communicate over http and parse JSON is able to easily interact with it. </p>
<p>Elasticsearch stores data in indexes. You can have multiple indexes on a single installation of Elasticsearch. It&#39;s up to you, the user, to decide how to organize your data into different indices. </p>
<p>In this class, we&#39;re going to go over the basics of:</p>
<ul>
<li>How to install Elasticsearch</li>
<li>How to load bulk data</li>
<li>How to do some basic querying</li>
</ul>
<h3 id="requirements">Requirements</h3>
<p>Elasticsearch requires Java 1.7 or higher. </p>
<h4 id="for-mac-and-windows">For Mac and Windows</h4>
<p>Visit this link:
<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a> </p>
<p>and select the distribution that matches your operating system. Accept the license agreement, download and install Java.</p>
<h4 id="windows-users-only">Windows Users Only</h4>
<p>To interact with Elasticsearch, we&#39;ll be using a command line program called cURL. This is widely available on unix based operating systems, but not windows. The easiest way to install cURL is to install git (also useful for other things!). You can install git here: <a href="http://git-scm.com/download/win">http://git-scm.com/download/win</a></p>
<p>When going through the install process make sure to select the option that says &quot;Install git and option unix tools&quot;. Once the installation is complete, you should be able to run the native Windows Powershell and the cURL command will be available. </p>
<h4 id="for-ubuntu">For Ubuntu</h4>
<p>For Ubuntu, you can paste the following into the command line:</p>
<pre><code class="lang-sh"><span class="hljs-built_in">sudo</span> add-apt-repository ppa:webupd8team/java
<span class="hljs-built_in">sudo</span> apt-get update
<span class="hljs-built_in">sudo</span> apt-get install oracle-java7-installer
</code></pre>
<p>and to make sure it installed correctly, you can run:</p>
<pre><code class="lang-sh">java -version
</code></pre>
<h3 id="getting-elasticsearch">Getting Elasticsearch</h3>
<p>You can download Elasticsearch here:
<a href="http://www.elasticsearch.org/overview/elkdownloads/">http://www.elasticsearch.org/overview/elkdownloads/</a></p>
<p>Once you&#39;ve downloaded it, extract the zip file. In your shell (terminal on Mac, Powershell on Windows), <code>cd</code> into the extracted directory and run</p>
<pre><code class="lang-sh">./bin/plugin -i elasticsearch/marvel/latest
</code></pre>
<p>This will install the Marvel plugin, which has a more user friendly console (called Sense) that we can use to interact with Elasticsearch.</p>
<h3 id="running-elasticsearch-">Running Elasticsearch!</h3>
<p>In your shell in the same directory as above, run </p>
<p>(Mac)</p>
<pre><code class="lang-sh">./bin/elasticsearch
</code></pre>
<p>(Windows)</p>
<pre><code class="lang-sh">./bin/elasticsearch.bat
</code></pre>
<p>You should see some output from Elasticsearch that should indicate that it&#39;s running. But let&#39;s query Elasticsearch to make sure! We&#39;ll do this two ways. From the command line and in the browser.</p>
<p>Open a new tab in your terminal, and run</p>
<pre><code class="lang-sh">curl -XGET http://localhost:<span class="hljs-number">9200</span>
</code></pre>
<p>curl is a command line tool to transfer data to and from a server over a variety of protocols, but in this case it&#39;s using http, just like most internet traffic does. the <code>-XGET</code> argument tells curl we want to perform a GET operation on the server, and <code>http://localhost:9200</code> is the default address of Elasticsearch. </p>
<p>Most server software that you run on your machine will show up at <code>http://localhost/</code> and most software has a default port number where it listens for requests. For Elasticsearch, the default port is <code>9200</code>, but really you can run it on any port you like. </p>
<p>The response should look like this (with a different name though)</p>
<pre><code class="lang-sh">{
  <span class="hljs-string">"status"</span> : <span class="hljs-number">200</span>,
  <span class="hljs-string">"name"</span> : <span class="hljs-string">"Jack Frost"</span>,
  <span class="hljs-string">"version"</span> : {
    <span class="hljs-string">"number"</span> : <span class="hljs-string">"1.3.4"</span>,
    <span class="hljs-string">"build_hash"</span> : <span class="hljs-string">"a70f3ccb52200f8f2c87e9c370c6597448eb3e45"</span>,
    <span class="hljs-string">"build_timestamp"</span> : <span class="hljs-string">"2014-09-30T09:07:17Z"</span>,
    <span class="hljs-string">"build_snapshot"</span> : <span class="hljs-literal">false</span>,
    <span class="hljs-string">"lucene_version"</span> : <span class="hljs-string">"4.9"</span>
  },
  <span class="hljs-string">"tagline"</span> : <span class="hljs-string">"You Know, for Search"</span>
}
</code></pre>
<p>Hooray! Elasticsearch works! You can also visit <code>http://localhost:9200</code> in your web browser, and you should see the same response.</p>
<h3 id="let-s-put-some-data-in-there">Let&#39;s Put Some Data in There</h3>
<p>So that we can get started right away practicing querying, I&#39;ve created a bulk file of chapters from Jane Austen&#39;s Pride and Prejudice. You can download the file here: <a href="https://raw.githubusercontent.com/kaitlin/elasticsearch/gh-pages/pride.json">https://raw.githubusercontent.com/kaitlin/elasticsearch/gh-pages/pride.json</a></p>
<p>Save the file somewhere you can <code>cd</code> into. Then we&#39;re going to do a bulk insert from the command line. After changing into the directory where you&#39;ve downloaded the file, run</p>
<pre><code class="lang-sh">curl <span class="hljs-operator">-s</span> -XPOST localhost:<span class="hljs-number">9200</span>/pride/_bulk --data-binary @pride.json; <span class="hljs-built_in">echo</span>
</code></pre>
<p>This command looks similar to above, but we&#39;ve changed a few things. It follows this loose format:</p>
<pre><code class="lang-sh">curl <span class="hljs-operator">-s</span> -XPOST HOSTNAME:PORT/INDEX_NAME/OPERATION_TYPE
</code></pre>
<p>Since we&#39;re sending data to Elasticsearch, we&#39;re using <code>-XPOST</code> instead of <code>-XGET</code>. Also, we&#39;ve added on to the url we&#39;re posting to. We&#39;ve decided to name the Elasticsearch index that&#39;s going to house this data <code>pride</code>, so we&#39;ve added that to the url path. And we&#39;re doing a bulk insert, so we&#39;ve also added <code>_bulk</code> to the url to let Elasticsearch know it should expect bulk data.</p>
<p>the <code>--data-binary</code> argument tells curl that binary data is about to follow. <code>@pride.json</code> dumps the JSON data out of the file and into the upload stream. The semicolon <code>;</code> ends the command. Then we add another command, <code>echo</code> to tell our terminal to print out the response returned from Elasticsearch. </p>
<p>You should see a response that looks something like this:</p>
<pre><code class="lang-sh">{<span class="hljs-string">"took"</span>:<span class="hljs-number">2008</span>,<span class="hljs-string">"errors"</span>:<span class="hljs-literal">false</span>,<span class="hljs-string">"items"</span>:[{<span class="hljs-string">"index"</span>:{<span class="hljs-string">"_index"</span>:<span class="hljs-string">"pride"</span>,<span class="hljs-string">"_type"</span>:<span class="hljs-string">"chapter"</span>,<span class="hljs-string">"_id"</span>:<span class="hljs-string">"1"</span>,<span class="hljs-string">"_version"</span>:<span class="hljs-number">1</span>,<span class="hljs-string">"status"</span>:<span class="hljs-number">201</span>}},{<span class="hljs-string">"index"</span>:{<span class="hljs-string">"_index"</span>:<span class="hljs-string">"pride"</span>,<span class="hljs-string">"_type"</span>:<span class="hljs-string">"chapter"</span>,<span class="hljs-string">"_id"</span>:<span class="hljs-string">"2"</span>,<span class="hljs-string">"_version"</span>:<span class="hljs-number">1</span>,<span class="hljs-string">"status"</span>:<span class="hljs-number">201</span>}},{<span class="hljs-string">"index"</span>:{<span class="hljs-string">"_index"</span>:<span class="hljs-string">"pride"</span>,<span class="hljs-string">"_type"</span>:<span class="hljs-string">"chapter"</span>,<span class="hljs-string">"_id"</span>:<span class="hljs-string">"3"</span>,<span class="hljs-string">"_version"</span>:<span class="hljs-number">1</span>,<span class="hljs-string">"status"</span>:<span class="hljs-number">201</span>}},....
</code></pre>
<p>The response is JSON object that tells you no errors occured, and it enumerates the items that were inserted into Elasticsearch under the <code>items</code> key. Now we have some data to query.</p>
<h2 id="getting-data-out-of-elasticsearch">Getting Data Out of Elasticsearch</h2>
<p>There are two main ways to fetch data from Elasticsearch. One is queries, and the other is filters. In general, queries should be used when you are doing a search on text or need to order results by relevance, and filters should be used when you want to filter on an exact value, or for binary(true/false) searches. You can also combine these types if you need to search within a filtered result set, or filter on a set of search results.</p>
<h3 id="querying-elasticsearch">Querying Elasticsearch</h3>
<p>Let&#39;s use the Sense console to make our queries. You can access Sense in your browser at <code>http://localhost:9200/_plugin/marvel/sense/index.html</code></p>
<p>First you&#39;ll see an overlay with some helpful tips on using Sense. After that, you can see the left pane which has a default query in it. This query:</p>
<pre><code class="lang-sh">GET /pride/_search
{
  <span class="hljs-string">"query"</span>: {
    <span class="hljs-string">"match_all"</span>: {}
  }
}
</code></pre>
<p>Will match everything. To restrict the search to just our pride index, we&#39;ve added the line <code>GET /pride/_search</code> above our query object. To run the query, click the green triangle. </p>
<p>You should see lots of results in the right pane. A total of 61 in fact (the number of chapters in Pride &amp; Prejudice).</p>
<p>All Elasticsearch queries start out with this basic structure:</p>
<pre><code class="lang-sh">GET /pride/_search
{
    <span class="hljs-string">"query"</span>: {

    }
}
</code></pre>
<p>This is important because there are soooo many different types of queries you can perform in Elasticsearch. The only way to get familiar with them all is to read the documentation on the Query DSL (DSL == Domain Specific Language) located here: <a href="http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl.html">http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl.html</a></p>
<p>But for some reason, all of the examples in the documentation leave out this basic structure and the examples all start as if you&#39;re filling in the basic structure above with more details. So if you&#39;re copying from an example in the docs and you get a <code>SearchQueryParseException</code>, try wrapping your query with the above structure.</p>
<h4 id="doesn-t-pride-and-prejudice-have-a-famous-line-">Doesn&#39;t Pride and Prejudice Have a Famous Line ?</h4>
<p>Yes! And it has the words &quot;truth universally acknowledged&quot;. Let&#39;s search for that and see what chapter it appears in. </p>
<pre><code class="lang-sh">GET /pride/_search
{
    <span class="hljs-string">"query"</span>: {
        <span class="hljs-string">"match"</span>: {
           <span class="hljs-string">"_all"</span>: <span class="hljs-string">"truth universally acknowledged"</span>
        }
    }
}
</code></pre>
<p>This looks similar to our first query, except that we&#39;ve added text to match. You should have 30 hits. Hmm, that didn&#39;t quite give us what we were looking for. Cruising through the text of the chapters we can see that it returned results for chapters that had any one of these three words. Let&#39;s try adding the <code>and</code> operator to the match query.</p>
<pre><code class="lang-sh">GET /pride/_search
{
    <span class="hljs-string">"query"</span>: {
        <span class="hljs-string">"match"</span>: {
           <span class="hljs-string">"_all"</span>: {
             <span class="hljs-string">"query"</span>: <span class="hljs-string">"truth universally"</span>,
             <span class="hljs-string">"operator"</span>: <span class="hljs-string">"and"</span>
           }
        }
    }
}
</code></pre>
<p>In this query, we&#39;ve added more attributes to the query, so instead of text as the value for the <code>_all</code> key, we have an object instead. This object has <code>query</code> and <code>operator</code> keys. The <code>query</code> is our actual text query, and the <code>operator</code> is the string &quot;and&quot; to tell elasticsearch we want all of these words to appear. </p>
<p>This time, when we run the query we get two results. So, there are two chapters that have both &quot;truth&quot; and &quot;universally&quot; in them. But the words aren&#39;t necessarily next to each other. What we want now is a phrase query.</p>
<pre><code class="lang-sh">GET /pride/_search
{
    <span class="hljs-string">"query"</span>: {
        <span class="hljs-string">"match"</span>: {
           <span class="hljs-string">"_all"</span>: {
             <span class="hljs-string">"query"</span>: <span class="hljs-string">"truth universally"</span>,
             <span class="hljs-string">"type"</span>: <span class="hljs-string">"phrase"</span>
           }
        }
    }
}
</code></pre>
<p>This query looks similar to the one above, but instead of using an operator, we&#39;re specifying a query <code>type</code> from a set of predefined types. In this case, it&#39;s <code>phrase</code>, indicating that not only do we want all these words to appear in the result, but we want them to be next to each other as well. This show&#39;s us one result, Chapter One. In fact, it&#39;s the first line of the book!</p>
<p>OK, now let&#39;s say that I can&#39;t remember when Mr. Collins enters the story. Well that&#39;s easy, I&#39;ll just search for the phrase &quot;Mr. Collins&quot; just like above.</p>
<pre><code class="lang-sh">GET /pride/_search
{
    <span class="hljs-string">"query"</span>: {
        <span class="hljs-string">"match"</span>: {
           <span class="hljs-string">"text"</span>: {
             <span class="hljs-string">"query"</span>: <span class="hljs-string">"Mr. Collins"</span>,
             <span class="hljs-string">"type"</span>: <span class="hljs-string">"phrase"</span>
           }
        }
    }
}
</code></pre>
<p>So this looks OK, except the chapters aren&#39;t ordered by their chapter number. I want to sort them in ascending order by the chapter attribute of each object. The sort key should be adjacent to your top level query object. Like this:</p>
<pre><code class="lang-sh">GET /pride/_search
{
    <span class="hljs-string">"query"</span>: {
        <span class="hljs-string">"match"</span>: {
           <span class="hljs-string">"text"</span>: {
             <span class="hljs-string">"query"</span>: <span class="hljs-string">"Mr. Collins"</span>,
             <span class="hljs-string">"type"</span>: <span class="hljs-string">"phrase"</span>
           }
        }
    },
    <span class="hljs-string">"sort"</span> : [
      {<span class="hljs-string">"chapter"</span> : {<span class="hljs-string">"order"</span> : <span class="hljs-string">"asc"</span>}}
    ]
}
</code></pre>
<p>The sort key has an array of objects for its value. Each sort object has a key with the name of the attribute we&#39;re sorting by, and that key contains an object that describes the order of the sort. In this case, the order is &quot;asc&quot; for ascending. </p>
<p>There are dozens of ways to query Elasticsearch. Try reading through all the different query types at <a href="http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-queries.html">http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-queries.html</a> and trying some out for yourself!</p>
<h3 id="filtering-in-elasticsearch">Filtering in Elasticsearch</h3>
<p>Let&#39;s say we want to retrieve some specific chapters from the book. Since we&#39;re going to be selecting for specific values, a filter is most efficient. Here&#39;s an example that retrieves chapters 10-20. We can use a range filter.</p>
<pre><code class="lang-sh">GET /pride/_search
{
    <span class="hljs-string">"query"</span>: {
      <span class="hljs-string">"constant_score"</span> : {
        <span class="hljs-string">"filter"</span> : {
              <span class="hljs-string">"range"</span> : {
                  <span class="hljs-string">"chapter"</span> : {
                      <span class="hljs-string">"gte"</span>: <span class="hljs-number">10</span>,
                      <span class="hljs-string">"lte"</span>: <span class="hljs-number">20</span>
                  }
              }
          }
      }
    }
}
</code></pre>
<p>This filters out chapters that are greater than or equal to 10 and less than or equal to 20. What if I want to combine this with a search? Well we can add a term filter for that. But once we add more than one filter, the structure gets a bit more complicated.</p>
<pre><code class="lang-sh">GET /pride/_search
{
  <span class="hljs-string">"query"</span>: {
    <span class="hljs-string">"filtered"</span> : {
        <span class="hljs-string">"filter"</span> : {
            <span class="hljs-string">"and"</span> : [
                {
                    <span class="hljs-string">"range"</span> : {
                        <span class="hljs-string">"chapter"</span> : {
                            <span class="hljs-string">"gte"</span> : <span class="hljs-number">10</span>,
                            <span class="hljs-string">"lte"</span> : <span class="hljs-number">20</span>
                        }
                    }
                },
                {
                    <span class="hljs-string">"term"</span> : { <span class="hljs-string">"text"</span> : <span class="hljs-string">"darcy"</span> }
                }
            ]
        }
    }
  }
}
</code></pre>
<p>Notice how we&#39;ve put each filter to be applied into an array with the key &quot;and&quot;. This means that we want all the filters to apply to the result set. The &quot;and&quot; array is nested inside a &quot;filter&quot; key, which is then nested inside a &quot;filtered&quot; key. And of course the whole thing is wrapped in a &quot;query&quot; object. </p>
<p>Whew! As you can see the queries can get large and complicated, but the query DSL is powerful and specific enough to be used for pretty much any logical combination you can imagine. Continue reading about the different filters available here: <a href="http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-filters.html">http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-filters.html</a></p>
<h3 id="that-s-it-">That&#39;s It!</h3>
<p>This covers the basics of installing and using Elasticsearch. Here are some more resources to keep you going:</p>
<ul>
<li><a href="http://exploringelasticsearch.com/">http://exploringelasticsearch.com/</a></li>
<li><a href="http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/index.html">http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/index.html</a></li>
<li><a href="http://www.elasticsearchtutorial.com/elasticsearch-in-5-minutes.html">http://www.elasticsearchtutorial.com/elasticsearch-in-5-minutes.html</a></li>
<li>This repo: <a href="https://github.com/kaitlin/elasticsearch">https://github.com/kaitlin/elasticsearch</a></li>
</ul>
<p>Thanks for watching!</p>
      </section>
      <footer>
        <p>Project maintained by <a href="https://github.com/kaitlin">kaitlin</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
